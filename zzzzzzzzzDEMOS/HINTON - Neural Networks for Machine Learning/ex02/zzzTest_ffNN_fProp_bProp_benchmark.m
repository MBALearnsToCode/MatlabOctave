% This script benchmark the accuracy and speed performnances of
% the FPROP_BPROP method of the FFNN package with a custom,
% hand-coded version of forward and backward propagation 

function zzzTest_ffNN_fProp_bProp_benchmark...
   (numBenchmarkBatches = 1)

   % HYPER-PARAMETERS
   batchsize = 100;
      % Mini-batch size.
   learning_rate = 0.1;
      % Learning rate; default = 0.1.
   momentum = 0.9;
      % Momentum; default = 0.9.
   numhid1 = 50;
      % Dimensionality of embedding space; default = 50.
   numhid2 = 200;
      % Number of units in hidden layer; default = 200.
   init_wt = 0.01;
      % Standard deviation of the normal distribution
      % which is sampled to get the initial weights;
      % default = 0.01
   timeScale = 1e-3;

   % LOAD DATA
   [train_input, train_target, ~, ~, ~, ~, vocab] = ...
      load_data(batchsize);
   [numwords, batchsize, numbatches] = size(train_input); 
   vocab_size = size(vocab, 2);

   % INITIALIZE WEIGHTS AND BIASES.
   word_embedding_weights = ...
      init_wt * randn(vocab_size, numhid1);
   embed_to_hid_weights = ...
      init_wt * randn(numwords * numhid1, numhid2);
   hid_to_output_weights = init_wt * randn(numhid2, vocab_size);
   hid_bias = init_wt * randn(numhid2, 1);
   output_bias = init_wt * randn(vocab_size, 1);

   ffNN = class_ffNN(numwords, ...
      {[vocab_size numhid1] ...
      [(numwords * numhid1 + 1) numhid2] ...
      [(numhid2 + 1) vocab_size]}, ...
      {'embedClassIndices_inRealFeatures' ...
      'logistic' 'softmax'}, false, false);
   ffNN.weights{1} = word_embedding_weights;
   ffNN.weights{2} = [hid_bias'; embed_to_hid_weights];
   ffNN.weights{3} = [output_bias'; hid_to_output_weights];
   
   word_embedding_weights_gradient = ...
      zeros(vocab_size, numhid1);

   expansion_matrix = eye(vocab_size);

   eqChk = true;
   ffNN_timeStats.fProp_bProp = ...
      handCode_timeStats.fProp_bProp = 0;
   ffNN_timeStats.activs = handCode_timeStats.activs = ...
      [0 0 0 0];   
   ffNN_timeStats.signals = handCode_timeStats.signals = ...
      [0 0 0];
   ffNN_timeStats.costAvg = handCode_timeStats.costAvg = 0;
   ffNN_timeStats.signalGrads = ...
      handCode_timeStats.signalGrads = [0 0 0];
   ffNN_timeStats.weightGrads = ...
      handCode_timeStats.weightGrads = [0 0 0];  
   ffNN_timeStats.activGrads = ...
      handCode_timeStats.activGrads = [0 0 0];
   ffNN_timeStats.weightRegul = [0 0 0];      
      
   for (batch = 1 : numBenchmarkBatches)
      fprintf('\rBatch #%i', batch);
      b = unidrnd(numbatches);
      input_batch = train_input(:, :, b);
      target_batch = train_target(:, :, b);

      [weightGrads costAvg_exclWeightPenalty ...
         costAvg_inclWeightPenalty hypoOutput activs ...
         weightRegulParams timeStats] = fProp_bProp(ffNN, ...
         input_batch', target_batch', vocab_size, {{'L2'} [0]});
      ffNN_timeStats.fProp_bProp += ...
         (timeStats.fProp_bProp ...
         - ffNN_timeStats.fProp_bProp) / batch;
      ffNN_timeStats.activs += ...
         (timeStats.activs ...
         - ffNN_timeStats.activs) / batch;
      ffNN_timeStats.signals += ...
         (timeStats.signals ...
         - ffNN_timeStats.signals) / batch;
      ffNN_timeStats.costAvg += ...
         (timeStats.costAvg ...
         - ffNN_timeStats.costAvg) / batch;
      ffNN_timeStats.signalGrads += ...
         (timeStats.signalGrads ...
         - ffNN_timeStats.signalGrads) / batch;
      ffNN_timeStats.weightGrads += ...
         (timeStats.weightGrads ...
         - ffNN_timeStats.weightGrads) / batch;
      ffNN_timeStats.activGrads += ...
         (timeStats.activGrads ...
         - ffNN_timeStats.activGrads) / batch;
      ffNN_timeStats.weightRegul += ...
         (timeStats.weightRegul ...
         - ffNN_timeStats.weightRegul) / batch;
      
      
      
      timeStats0.fProp_bProp = 0;
      timeStats0.activs = [0 0 0 0];   
      timeStats0.signals = [0 0 0];
      timeStats0.costAvg = 0;
      timeStats0.signalGrads = [0 0 0];
      timeStats0.weightGrads = [0 0 0];  
      timeStats0.activGrads = [0 0 0]; 
      %% COMPUTE STATE OF WORD EMBEDDING LAYER.
      % Look up the inputs word indices in the
      % word_embedding_weights matrix.
      timeStats0.activs(1) = 0;      
      tic;
      embedding_layer_state = reshape(...
         word_embedding_weights(reshape(input_batch, 1, []), :)',...
         numhid1 * numwords, []);
      timeStats0.fProp_bProp += timeStats0.signals(1) = ...
         toc / timeScale;
      timeStats0.activs(2) = 0;

      %% COMPUTE STATE OF HIDDEN LAYER.
      % Compute inputs to hidden units.
      tic;
      inputs_to_hidden_units = ...
         embed_to_hid_weights' * embedding_layer_state + ...
         repmat(hid_bias, 1, batchsize);
      timeStats0.fProp_bProp += timeStats0.signals(2) = ...
         toc / timeScale;
      % Apply logistic activation function.
      tic;
      hidden_layer_state = ...
         1 ./ (1 + exp(-inputs_to_hidden_units));
      timeStats0.fProp_bProp += timeStats0.activs(3) = ...
         toc / timeScale;

      %% COMPUTE STATE OF OUTPUT LAYER.
      % Compute inputs to softmax.
      tic;
      inputs_to_softmax = ...
         hid_to_output_weights' * hidden_layer_state ...
         + repmat(output_bias, 1, batchsize);
      timeStats0.fProp_bProp += timeStats0.signals(3) = ...
         toc / timeScale;
      tic;
      % Subtract maximum.     
      inputs_to_softmax = inputs_to_softmax...
        - repmat(max(inputs_to_softmax), vocab_size, 1);
      % Compute exp.
      output_layer_state = exp(inputs_to_softmax);
      % Normalize to get probability distribution.
      output_layer_state = output_layer_state ./ repmat(...
         sum(output_layer_state, 1), vocab_size, 1);
      timeStats0.fProp_bProp += timeStats0.activs(4) = ...
         toc / timeScale;
 
      % MEASURE LOSS FUNCTION.
      tic;
      %% Expand the target to a sparse 1-of-K vector.
      expanded_target_batch = ...
         expansion_matrix(:, target_batch);
      CE = -sum(sum(...
         expanded_target_batch .* log(output_layer_state))) ...
         / batchsize;
      timeStats0.fProp_bProp += timeStats0.costAvg = ...
         toc / timeScale;

      % COMPUTE DERIVATIVE.
      %% Compute derivative of cross-entropy loss function.
      tic;
      error_deriv = (output_layer_state ...
         - expanded_target_batch) /  batchsize;
      timeStats0.fProp_bProp += timeStats0.signalGrads(3) = ...
         toc / timeScale;
   
      % BACK PROPAGATE.
      %% OUTPUT LAYER.
      tic;
      hid_to_output_weights_gradient = ...
         hidden_layer_state * error_deriv';
      output_bias_gradient = sum(error_deriv, 2);
      timeStats0.fProp_bProp += timeStats0.weightGrads(3) = ...
         toc / timeScale;
   
      tic;   
      back_propagated_deriv_1 = ...
         (hid_to_output_weights * error_deriv) ...
         .* hidden_layer_state .* (1 - hidden_layer_state);
      timeStats0.fProp_bProp += timeStats0.signalGrads(2) = ...
         toc/timeScale; 

      %% HIDDEN LAYER.
      tic;
      embed_to_hid_weights_gradient = ...
         embedding_layer_state * back_propagated_deriv_1';
      hid_bias_gradient = sum(back_propagated_deriv_1, 2);
      timeStats0.fProp_bProp += timeStats0.weightGrads(2) = ...
         toc / timeScale;

      tic;
      back_propagated_deriv_2 = ...
         embed_to_hid_weights * back_propagated_deriv_1;
      timeStats0.fProp_bProp += timeStats0.signalGrads(1) = ...
         toc / timeScale;

      word_embedding_weights_gradient(:) = 0;
      %% EMBEDDING LAYER.
      tic;
      for (w = 1 : numwords)
         word_embedding_weights_gradient = ...
            word_embedding_weights_gradient + ...   
            expansion_matrix(:, input_batch(w, :)) * ...
            (back_propagated_deriv_2(1 + (w - 1) * numhid1 : w * numhid1, :)');
      endfor
      timeStats0.fProp_bProp += timeStats0.weightGrads(1) = ...
         toc / timeScale;

      handCode_timeStats.fProp_bProp += ...
         (timeStats0.fProp_bProp ...
         - handCode_timeStats.fProp_bProp) / batch;
      handCode_timeStats.activs += ...
         (timeStats0.activs ...
         - handCode_timeStats.activs) / batch;
      handCode_timeStats.signals += ...
         (timeStats0.signals ...
         - handCode_timeStats.signals) / batch;
      handCode_timeStats.costAvg += ...
         (timeStats0.costAvg ...
         - handCode_timeStats.costAvg) / batch;
      handCode_timeStats.signalGrads += ...
         (timeStats0.signalGrads ...
         - handCode_timeStats.signalGrads) / batch;
      handCode_timeStats.weightGrads += ...
         (timeStats0.weightGrads ...
         - handCode_timeStats.weightGrads) / batch;
      handCode_timeStats.activGrads += ...
         (timeStats0.activGrads ...
         - handCode_timeStats.activGrads) / batch;
         
      bW_g1 = word_embedding_weights_gradient;
      bW_g2 = [hid_bias_gradient'; ...
         embed_to_hid_weights_gradient];
      bW_g3 = [output_bias_gradient'; ...
         hid_to_output_weights_gradient];
      eqChk = and(eqChk, equalTest(weightGrads{1}, bW_g1), ...
         equalTest(weightGrads{2}, bW_g2), ...
         equalTest(weightGrads{3}, bW_g3));
         
   endfor
           
   fprintf('\n\nEQUALITY CHECK: ffNN Weight Grads vs. Hand-Coded Weight Grads:\n');
   eqChk
   
   fprintf('\nTIME COMPARISON: ffNN %i ms vs. Hand-Coded %i ms (%g%%)\n\n', ...
      ffNN_timeStats.fProp_bProp, ...
      handCode_timeStats.fProp_bProp, ...
      100 * (ffNN_timeStats.fProp_bProp ...
      / handCode_timeStats.fProp_bProp - 1));
   ffNN_timeChk = equalTest(ffNN_timeStats.fProp_bProp, ...
      sum(ffNN_timeStats.activs) ...
      + sum(ffNN_timeStats.signals) ...
      + ffNN_timeStats.costAvg ...
      + sum(ffNN_timeStats.signalGrads) ...
      + sum(ffNN_timeStats.weightGrads) ...
      + sum(ffNN_timeStats.activGrads) ...
      + sum(ffNN_timeStats.weightRegul))
   handCode_timeChk = ...
      equalTest(handCode_timeStats.fProp_bProp, ...
      sum(handCode_timeStats.activs) ...
      + sum(handCode_timeStats.signals) ...
      + handCode_timeStats.costAvg ...
      + sum(handCode_timeStats.signalGrads) ...
      + sum(handCode_timeStats.weightGrads) ...
      + sum(handCode_timeStats.activGrads))
   ffNN_timeStats
   handCode_timeStats

endfunction