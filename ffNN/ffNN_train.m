function [ffNN_trained costAvgHistory] = ffNN_train...
   (input_rowMat, ffNN, targetOutput_rowMat, maxNumIters, ...
   regulParam = 0, params_init = {}, ...
   alsoTrainInput = false, funcOptimMethod = @fmincg, ...
   initSigma = 1e-2, randInit = true)

   fprintf('\nTraining Forward-Feeding Neural Network...\n');
  
   input_colVec = input_rowMat(:);

   ffNN_trained = ffNN;

   if isempty(params_init)
      ffNN_trained = ffNN_initParams...
         (ffNN_trained, initSigma, 'normal', randInit);
   else   
      ffNN_trained.params = ...
         [ffNN_trained.params{1} params_init];
   endif
  
   if (alsoTrainInput)
      state_init_colVec = [input_colVec; ...
         convertArrsToColVec(ffNN_trained.params)];
      costAvgFunc = @(ip_v) ...
         ffNN_costWRegul_n_inputGrad_n_paramGrads...
         (ip_v, ffNN_trained, targetOutput_rowMat, ...
         regulParam);
   else
      state_init_colVec = ...
         convertArrsToColVec(ffNN_trained.params);
      costAvgFunc = @(p_v) ...
         ffNN_costWRegul_n_inputGrad_n_paramGrads...
         ([input_colVec; p_v], ffNN_trained, ...
         targetOutput_rowMat, regulParam, false);
   endif
      
   optimOptions = ...
      optimset('GradObj', 'on', 'MaxIter', maxNumIters);
   
   [state_trained_colVec costAvgHistory] = ...
      funcOptimMethod(costAvgFunc, state_init_colVec, ...
      optimOptions);

   if (alsoTrainInput)     
      input_n_params_trained = ...
         convertColVecToArrs(state_trained_colVec, ...
         [size(input_rowMat) ffNN_trained.paramDimSizes]);
      input_trained = input_n_params_trained{1};
      ffNN_trained.params = input_n_params_trained(2 : end);
   else      
      input_trained = input_rowMat;
      ffNN_trained.params = ...
         convertColVecToArrs(state_trained_colVec, ...
         ffNN_trained.paramDimSizes);
   endif

   ffNN_trained = ffNN_fProp_bProp...
      (input_trained, ffNN_trained, targetOutput_rowMat, ...
      regulParam);

   fprintf('   Iterations finished! .|.\n\n');

end