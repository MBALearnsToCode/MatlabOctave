function [ffNN_updated ...
   ffNN_immedParamChangesMemory_updated ...
   trainCostsAvg_noRegul_bfrUpdates ...
   validCostsAvg_noRegul_aftUpdates] = ...
   ffNN_gradDesc_nesterovAccGrad_or_momentum...
   (ffNN, ffNN_immedParamChangesMemory, ...
   trainInput_Arr, trainTargetOutput_rowMat, ...
   regulParam = 0, learningRate = 1e-1, momentumRate = 0, ...
   numReps = 1, returnTrainCostsAvg = true, ...
   validInput_Arr = [], validTargetOutput_rowMat = [], ...   
   nesterovAccGrad = true)
   
   ffNN_updated = ffNN;
   ffNN_immedParamChangesMemory_updated = ...
      ffNN_immedParamChangesMemory;
   L = ffNN_updated.numLayers;
   
   if (returnTrainCostsAvg)
      trainCostsAvg_noRegul_bfrUpdates = [];
   endif
   
   returnValidCostsAvg = ~isempty(validInput_Arr) ...
      && ~isempty(validTargetOutput_rowMat);
   if (returnValidCostsAvg)
      validCostsAvg_noRegul_aftUpdates = [];
   endif
   
   if (momentumRate)
   
      if (nesterovAccGrad)
      
         for (r = 1 : numReps)
         
            if (returnTrainCostsAvg)
               trainCostsAvg_noRegul_bfrUpdates(r) = ...
                  ffNN_fProp_bProp...
                  (trainInput_Arr, ffNN_updated, ...
                  trainTargetOutput_rowMat, ...
                  0, false).costAvg_noRegul;
            endif
         
            ffNN_temp = ffNN_updated;      
            for (l = 2 : L)
               ffNN_temp.params{l} += momentumRate ...
                  * ffNN_immedParamChangesMemory_updated{l};
            endfor               
            ffNN_temp = ffNN_fProp_bProp...
               (trainInput_Arr, ffNN_temp, ...
               trainTargetOutput_rowMat, regulParam);
            ffNN_updated.takeTime = ffNN_temp.takeTime;
            
            for (l = 2 : L)
               ffNN_updated.params{l} += ...
                  ffNN_immedParamChangesMemory_updated{l} = ...
                  momentumRate ...
                  * ffNN_immedParamChangesMemory_updated{l} ...
                  - learningRate * ffNN_temp.paramGrads{l};
            endfor
            
            if (returnValidCostsAvg)
               validCostsAvg_noRegul_aftUpdates(r) = ...
                  ffNN_fProp_bProp...
                  (validInput_Arr, ffNN_updated, ...
                  validTargetOutput_rowMat, ...
                  0, false).costAvg_noRegul;
            endif
            
         endfor
   
      else
      
         for (r = 1 : numReps)
            
            ffNN_updated = ffNN_fProp_bProp...
               (trainInput_Arr, ffNN_updated, ...
               trainTargetOutput_rowMat, regulParam);
      
            if (returnTrainCostsAvg)
               trainCostsAvg_noRegul_bfrUpdates(r) = ...
                  ffNN_updated.costAvg_noRegul;
            endif

            for (l = 2 : L)
               ffNN_updated.params{l} += ...
                  ffNN_immedParamChangesMemory_updated{l} = ...
                  momentumRate ...
                  * ffNN_immedParamChangesMemory_updated{l} ...
                  - learningRate * ffNN_updated.paramGrads{l};
            endfor
                   
            if (returnValidCostsAvg)
               validCostsAvg_noRegul_aftUpdates(r) = ...
               ffNN_fProp_bProp...
               (validInput_Arr, ffNN_updated, ...
               validTargetOutput_rowMat, ...
               0, false).costAvg_noRegul;
            endif
            
         endfor
         
      endif
      
   else 
      
      for (r = 1 : numReps)
      
         ffNN_updated = ffNN_fProp_bProp...
            (trainInput_Arr, ffNN_updated, ...
            trainTargetOutput_rowMat, regulParam);
            
         if (returnTrainCostsAvg)
            trainCostsAvg_noRegul_bfrUpdatesbfr(r) = ...
               ffNN_updated.costAvg_noRegul;
         endif
            
         for (l = 2 : L)
            ffNN_updated.params{l} += ...
               ffNN_immedParamChangesMemory_updated{l} = ...
               - learningRate * ffNN_updated.paramGrads{l};
         endfor
         
         if (returnValidCostsAvg)
            validCostsAvg_noRegul_aftUpdates(r) = ...
               ffNN_fProp_bProp...
               (validInput_Arr, ffNN_updated, ...
               validTargetOutput_rowMat, ...
               0, false).costAvg_noRegul;
         endif
         
      endfor
      
   endif
   
end