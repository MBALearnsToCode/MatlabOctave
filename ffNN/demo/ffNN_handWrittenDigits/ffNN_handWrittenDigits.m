function ffNN = ffNN_handwrittenDigits...
   (numsHid = [300 100], weightPenaltyTerm = 0, ...
   numEpochs = 30, numIters_perBatch = 9); 
   
   close all;
   
   % load data
   [trainInput trainTargetOutput ...
   validInput validTargetOutput ...
   testInput testTargetOutput ...
   imgHeight imgWidth] = load_mNIST_11k;
   
   m = length(trainTargetOutput);
   
   
   % display random sample labels & images
   numDisplaySamples = 100;
   displaySamples_numRowsCols = sqrt(numDisplaySamples);
   randDisplaySamples = 1 : 100;
   
   [~, displayLabels] = max...
      (trainTargetOutput(randDisplaySamples, :), [], 2);
   fprintf('\n%i Sample Labels & Images:\n', numDisplaySamples);
   reshape(displayLabels, [displaySamples_numRowsCols ...
      displaySamples_numRowsCols])'
      
   plot2D_grayImages...
      (permute(trainInput(randDisplaySamples, :, :), [2 3 1]));
   
   
   % create Forward-Feeding Neural Network (FFNN):
   % all layers are Logistic transformation layers
   % with the top layer automatically set as 
   % a 10-way Softmax layer
   ffNN = class_ffNN...
      (inputDimSizes_perCase = 256, ...
      addlLayersNumsNodes = [numsHid 10], ...
      transformFuncs = {}, ...
      displayOverview = false, ...
      initWeights_rand = true);
   
   
   % reshape data to fit model's architecture
   trainInput = trainInput(:, :);
   validInput = validInput(:, :);
   testInput = testInput(:, :);

   % train FFNN with CONJUGATE GRADIENT
   ffNN = train_conjGrad...
      (ffNN_init = ffNN, ...
      dataArgs = {trainInput trainTargetOutput ...
                  validInput validTargetOutput ...
                  testInput testTargetOutput}, ...
      targetOutput_isClassIndcsColVec = false, ...
      numIters_perBatch = numIters_perBatch, ...
      trainNumEpochs = numEpochs, ...
      trainBatchSize = false, ...
      trainRandShuff = false, ...
      trainCostApproxChunk_numBatches = 1, ...
      validCostCalcInterval_numChunks = 3, ...
      weightRegulArgs = {{'L2'} [weightPenaltyTerm]}, ...
      connectProbs = [1.0], ...
      bestStop = true);

      
   % visualize learned 1st-layer weights
   % to see what detected features are like;
   % we will see many features detecting strokes
   % and hooks, which are relevant in distinguishing
   % one digit from another
   weights = ffNN.weights;
   weights_layer1 = weights{1};
   % for visualization purposes, we ignore bias terms
   weights_layer1 = rmBiasElems(weights_layer1);
   % reshape weights for visualization
   weights_layer1 = permute(reshape(weights_layer1', ...
      [numsHid(1) imgHeight imgWidth]), [2 3 1]);
   % visualize weights
   plot2D_grayImages(weights_layer1);   
   
endfunction