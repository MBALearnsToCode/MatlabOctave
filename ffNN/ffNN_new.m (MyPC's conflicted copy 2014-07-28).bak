function f = ffNN_new(inputDimSizes_perCase_vec, ...
   addlLayersNumsNodes_vec_OR_paramDimSizes_list = [], ...
   transformFuncs_list = {}, regulFuncs_list = {}, ...
   overview = true, initParams = true, ...
   sigma_or_epsilon = 1e-2, distrib = 'normal')
   
   f.hypoOutput = [];
   f.costFuncType = '';
   f.costAvg_wRegul = f.costAvg_noRegul = 0;
   f.numLayers = 1;
   f.numParams = 0;
   f.inputDimSizes_perCase = inputDimSizes_perCase_vec;
   f.paramDimSizes{1} = [0 0];
   f.transformFuncs{1} = {};
   f.regulFuncs{1} = {};
   f.activGrads{1} = f.activs{1} = f.signalGrads{1} = ...
      f.paramGrads{1} = f.params{1} = [];
   f.regulParams(1) = 0;
   
   if iscell...
      (addlLayersNumsNodes_vec_OR_paramDimSizes_list)
      
      if isempty...
         (addlLayersNumsNodes_vec_OR_paramDimSizes_list)
         return;
      endif
      
      paramDimSizes = [[] ...
         addlLayersNumsNodes_vec_OR_paramDimSizes_list];
      numLayers = length(paramDimSizes);
      
   else

      numsNodes = [inputDimSizes_perCase_vec ...
         addlLayersNumsNodes_vec_OR_paramDimSizes_list];
      if isscalar(numsNodes)
         numsNodes = [numsNodes 1];
      endif
      numLayers = length(numsNodes);
      
      % Dimensions of Parameter Matrices can only be set 
      % later according to whether Transformation Functions
      % have Bias terms
      
   endif
   
   transformFuncs = [{{}} transformFuncs_list];
   regulFuncs = [{{}} regulFuncs_list];
   numTransformFuncs_specified = length(transformFuncs);   
   for (l = (numTransformFuncs_specified + 1) : numLayers)
      transformFuncs{l} = 'logistic';
   endfor

   if ~iscell...
      (addlLayersNumsNodes_vec_OR_paramDimSizes_list)      
      for (l = 2 : numLayers)         
         if strcmp(class(transformFuncs{l}), 'char')
            transformFuncs{l} = ...
               ffNN_definedTransformFunc(transformFuncs{l});
         endif         
         paramDimSizes{l} = ...
            [(numsNodes(l - 1) ...
            + transformFuncs{l}.addBias) numsNodes(l)];            
      endfor   
   endif

   if (numTransformFuncs_specified < numLayers) && ...
   
      if (paramDimSizes{numLayers}(2) <= 2)
         transformFuncs{numLayers} = 'logistic';
      else
         transformFuncs{numLayers} = 'softmax';
      endif
      
   endif
   
   for (l = (length(regulFuncs) + 1) : numLayers)
      regulFuncs{l} = 'L2';
   endfor
   
   for (l = 2 : numLayers)
      f = ffNN_addLayer(f, paramDimSizes{l}, ...
         transformFuncs{l}, regulFuncs{l});
   endfor

   if (initParams)
      f = ffNN_initParams(f, sigma_or_epsilon, distrib);
   endif
   
   if (overview)
      ffNN_overview(f);
   endif    

end