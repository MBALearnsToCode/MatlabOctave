function [ffNN_updated trainCostAvg_noRegul_approx ...
   validCostAvg_noRegul testCostAvg_noRegul ...
   trainCostsAvg_noRegul_approx validCostsAvg_noRegul ...   
   ffNN_immedParamChangesMemory_updated] = ...
   ffNN_trainGradDesc(ffNN, dataArgs_list, ...
   targetOutputs_areClassIndcsColVec_ofNumClasses = ...
      false, ...
   trainNumEpochs = 1, trainBatchSize = false, ...   
   trainRandShuff = true, ...
   trainCostApproxChunk_numBatches = 1, ...
   validCostCalcInterval_numChunks = 1, ...
   learningRate_init = 1e-1, momentumRate_init = 9e-1, ...
   nesterovAccGrad = true, ...
   paramRegulArgs_list = ...
      {{const_MacKay_empBayes_str} []}, ...
   bestStop = true, ffNN_immedParamChangesMemory = {}, ...
   saveEvery_numMins = 3, ...
   saveFileName = 'ffNN_trained.mat')
   % zzzBORED = 'Z' - waiting for Octave's TIMER functionality
   
   ffNN_updated = ffNN;   
   L = ffNN_updated.numLayers;   
   if isempty(ffNN_immedParamChangesMemory)
      ffNN_immedParamChangesMemory_updated = ...
         ffNN_initParamChangesMemory(ffNN_updated);
   else
      ffNN_immedParamChangesMemory_updated = ...
         ffNN_immedParamChangesMemory;
   endif
   trainCostAvg_noRegul_approx = validCostAvg_noRegul = ...
      testCostAvg_noRegul = 0;
   trainCostsAvg_noRegul_approx = ...
      validCostsAvg_noRegul = [];
   
   %%%%%%%%%%%%%%%%%%%%%%%%
   % fprintf('trainGradDesc:\n');
   % dataArgs_list
   %%%%%%%%%%%%%%%%%%%%%%%%
   
   setData = setTrainValidTestData(dataArgs_list, ...
      trainBatchSize, trainRandShuff);
   batchSize = setData.trainBatchSize;
   trainNumBatches = setData.trainNumBatches;
   trainBatchDim = setData.trainBatchDim;
   trainInput = setData.trainInput;
   trainTargetOutput = setData.trainTargetOutput;
   trainInput_batches = setData.trainInput_batches;
   trainTargetOutput_batches = ...
      setData.trainTargetOutput_batches;
   validInput = setData.validInput;
   validTargetOutput = setData.validTargetOutput;
   testInput = setData.testInput;
   testTargetOutput = setData.testTargetOutput;

   valid_provided = ~(isempty(validInput) ...
      || isempty(validTargetOutput));
   if (valid_provided)
      validBatchDim = max(arrNumDims(validInput), ...
         arrNumDims(validTargetOutput));
   endif
   if (valid_provided) & (bestStop)
      ffNN_best = ffNN_updated;
      validCostAvg_noRegul_best = Inf;
      toSaveBest = false;
   endif 
   
   test_provided = ~(isempty(testInput) ...
      || isempty(testTargetOutput));
   if (test_provided)
      testBatchDim = max(arrNumDims(testInput), ...
         arrNumDims(testTargetOutput));
   endif
   
   learningRate = learningRate_init;
   momentumRate = momentumRate_init;
       
   trainCostAvg_noRegul_currChunk = ...
      chunk = chunk_inEpoch = batch_inChunk = 0;
   
   validCostCalcInterval_numBatches = ...
      validCostCalcInterval_numChunks ...
      * trainCostApproxChunk_numBatches;
      
   preTerm = false;   
      
fprintf('\n\nTRAINING FORWARD-FEEDING NEURAL NETWORK BY GRADIENT DESCENT...\n\n');
   fprintf('   DATA SETS:\n');
   fprintf('      Training: %i cases\n', ...
      size(trainTargetOutput, 1));
   if (valid_provided)
      fprintf('      Validation: %i cases\n', ...
         rows(validTargetOutput));      
   endif
   if (test_provided)
      fprintf('      Test: %i cases\n', ...
         rows(testTargetOutput));
   endif
   
   fprintf('\n   TRAINING SETTINGS:\n');
   fprintf('      Training Epochs: %i\n', trainNumEpochs); 
fprintf('      Training Batches per Epoch: %i batches of %i', ...
      trainNumBatches, batchSize);
   if (trainRandShuff)
      fprintf(', shuffled in each epoch\n')
   else
      fprintf('\n');
   endif
   fprintf('      Learning Rate: %g\n', learningRate);
   if (momentumRate)
      fprintf('      Momentum: %g', momentumRate);
      if (nesterovAccGrad)
fprintf(',   applying Nesterov Accelerated Gradient (NAG)\n');
      else
         fprintf('\n');
      endif
   endif

   fprintf('      Weight Penalty Methods & Parameters:\n');
   paramRegulFuncs = [{{}} paramRegulArgs_list{1}];
   paramRegulParams = [0 paramRegulArgs_list{2}];
   for (l = 2 : L)
      if (length(paramRegulFuncs) < l)
         paramRegulFuncs{l} = paramRegulFuncs{l - 1};
      endif        
      if (length(paramRegulParams) < l)
         paramRegulParams(l) = paramRegulParams(l - 1);
      endif
      if strcmp(paramRegulFuncs{l}, ...
         const_MacKay_empBayes_str)         
         paramRegulParam_print = '';
      else
         paramRegulParam_print = ...
            sprintf(': penalty term = %g', ...
            paramRegulParams(l));
      endif
      fprintf(cstrcat('         Layer #', sprintf('%i', l),': ', ...
         paramRegulFuncs{l}, paramRegulParam_print, '\n'));
   endfor
   
   if (bestStop)
fprintf('      Model Selection by Best Validation Performance\n');
   endif
   fprintf('      Saving Results in "%s" on Working Directory every %i Minutes\n', ...
      saveFileName, saveEvery_numMins);
   fprintf('\n');
   fprintf('   TRAINING PROGRESS:\n');
% fprintf(cstrcat('      (pre-terminate by "', zzzBORED, '" key stroke)\n'));
fprintf('      Training Avg Cost (w/o Weight Penalty) approx''d w/ each chunk of %i batches\n',
      trainCostApproxChunk_numBatches);
fprintf('      Validation Avg Cost (w/o Weight Penalty) updated every %i batches\n', ...
      validCostCalcInterval_numBatches);
      
   lastSaveTime = trainStartTime = time;
   
   for (epoch = 1 : trainNumEpochs)
      
      if (trainRandShuff) && (epoch > 1)
         train_reshuffled = setTrainValidTestData...
            ({trainInput trainTargetOutput 1.0}, ...
            batchSize, trainRandShuff);
         trainInput_batches = ...
            train_reshuffled.trainInput_batches;
         trainTargetOutput_batches = ...
            train_reshuffled.trainTargetOutput_batches;    
      endif
      
      for (batch = 1 : trainNumBatches)
         
         if (trainNumBatches > 1)
            trainInput_batch = arrSubsetHighestDim...
              (trainInput_batches, batch);
            trainTargetOutput_batch = ...
               arrSubsetHighestDim...
               (trainTargetOutput_batches, batch);
         else
            trainInput_batch = trainInput_batches;
            trainTargetOutput_batch = ...
               trainTargetOutput_batches;
         endif
           
         if (momentumRate)
   
            if (nesterovAccGrad)      

               trainCostAvg_noRegul_currBatch = ...
                  ffNN_costAvg_noRegul(ffNN_updated, ...
                  trainInput_batch, ...
                  trainTargetOutput_batch, ...
         targetOutputs_areClassIndcsColVec_ofNumClasses, ...
                  trainBatchDim);
                  
               ffNN_temp = ffNN_updated;      
               for (l = 2 : L)
                  ffNN_temp.params{l} += momentumRate ...
                  * ffNN_immedParamChangesMemory_updated{l};
               endfor               
               ffNN_temp = ffNN_fProp_bProp(ffNN_temp, ...
                  trainInput_batch, ...
                  trainTargetOutput_batch, ...
         targetOutputs_areClassIndcsColVec_ofNumClasses, ...
                  {paramRegulFuncs paramRegulParams});
               ffNN_updated.takeTime = ffNN_temp.takeTime;
            
               for (l = 2 : L)
                  ffNN_updated.params{l} += ...
               ffNN_immedParamChangesMemory_updated{l} = ...
                     momentumRate ...
               * ffNN_immedParamChangesMemory_updated{l} ...
                  - learningRate * ffNN_temp.paramGrads{l};
               endfor    
   
            else
                  
               ffNN_updated = ffNN_fProp_bProp...
                  (ffNN_updated, trainInput_batch, ...
                  trainTargetOutput_batch, ...
         targetOutputs_areClassIndcsColVec_ofNumClasses, ...
                  {paramRegulFuncs paramRegulParams});
      
               trainCostAvg_noRegul_currBatch = ...
                  ffNN_updated.costAvg_noRegul;

               for (l = 2 : L)
                  ffNN_updated.params{l} += ...
               ffNN_immedParamChangesMemory_updated{l} = ...
                     momentumRate ...
               * ffNN_immedParamChangesMemory_updated{l} ...
               - learningRate * ffNN_updated.paramGrads{l};
               endfor
         
            endif
      
         else 
      
            ffNN_updated = ffNN_fProp_bProp...
               (ffNN_updated, trainInput_batch, ...
               trainTargetOutput_batch, ...
         targetOutputs_areClassIndcsColVec_ofNumClasses, ...               
               {paramRegulFuncs paramRegulParams});
            
            trainCostAvg_noRegul_currBatch = ...
               ffNN_updated.costAvg_noRegul;
            
            for (l = 2 : L)
               ffNN_updated.params{l} += ...
               ffNN_immedParamChangesMemory_updated{l} = ...
               - learningRate * ffNN_updated.paramGrads{l};
            endfor
            
         endif
         
         batch_inChunk++;         
         trainCostAvg_noRegul_currChunk += ...
            (trainCostAvg_noRegul_currBatch ...
            - trainCostAvg_noRegul_currChunk) ...
            / batch_inChunk;    
         
         if (batch_inChunk ==
            trainCostApproxChunk_numBatches) || ...
            (batch == trainNumBatches)
                        
            chunk_inEpoch++; chunk++;
            trainCostsAvg_noRegul_approx(chunk) = ...
               trainCostAvg_noRegul_currChunk;
               
            if (valid_provided && ((mod(batch, ...
            validCostCalcInterval_numBatches) == 0) || ...
            (batch == trainNumBatches)))
            
               validCostAvg_noRegul = ...
                  validCostsAvg_noRegul(chunk) = ...
                  ffNN_costAvg_noRegul(ffNN_updated, ...
                  validInput, validTargetOutput, ...
         targetOutputs_areClassIndcsColVec_ofNumClasses, ...
                  validBatchDim);
   
               if (bestStop && (validCostAvg_noRegul ...
                  < validCostAvg_noRegul_best))
                  ffNN_best = ffNN_updated;               
                  validCostAvg_noRegul_best = ...
                     validCostAvg_noRegul;
                  toSaveBest = true;               
               endif          
          
            endif
            
            if (time > lastSaveTime + saveEvery_numMins * 60)
               if (bestStop && valid_provided)
                  if (toSaveBest)
                     ffNN_save(ffNN_updated, saveFileName);
                     lastSaveTime = time;                  
                     toSaveBest = false;
                  endif
               else
                  ffNN_save(ffNN_updated, saveFileName);
                  lastSaveTime = time;
               endif
               
            endif            
            
            trainCurrTime = time;
            trainElapsedTime = trainCurrTime - trainStartTime;
fprintf('\r      Epoch %i Batch %i: TRAIN = %g | VALID = %g | elapsed = %is      ', ...
               epoch, batch, ...
               trainCostAvg_noRegul_currChunk, ...
               validCostAvg_noRegul, ...
               trainElapsedTime);

            validCostsAvg_noRegul_0asNA = ...
               validCostsAvg_noRegul;
            validCostsAvg_noRegul_0asNA...
               (validCostsAvg_noRegul_0asNA == 0) = NA;
            clf;      
            hold on;
            title('LEARNING CURVES');
xlabel(sprintf('%i CHUNKS (1 Chunk = %i Batches, 1 Batch = %i Cases) | elapsed: %is', ...
               chunk, ...
               trainCostApproxChunk_numBatches, ...
               batchSize, trainElapsedTime));
            ylabel('Avg Costs (w/o Weight Penalty)');
            plot(trainCostsAvg_noRegul_approx, 'b');
            plot(validCostsAvg_noRegul_0asNA, '.', ...
               'color', 'r', 'markersize', 9);
legend(sprintf('TRAINING (last chunk) = %.3g', ...          
               trainCostAvg_noRegul_currChunk), ...
               sprintf('VALIDATION = %.3g', ...
               validCostAvg_noRegul));
            hold off;
            pause(0);
               
            trainCostAvg_noRegul_currChunk = ...
               batch_inChunk = 0;  
 
            if (batch == trainNumBatches)         
               chunk_inEpoch = 0;
            endif
 
         endif
         
      endfor
   
   endfor

fprintf('\n\n   RESULTS:   Training Finished w/ Following Avg Costs (w/o Weight Penalty):\n');

   trainCostAvg_noRegul_approx = ...
      trainCostsAvg_noRegul_approx(end);
   fprintf('      Training (approx''d by last chunk): %g\n', ...
      trainCostAvg_noRegul_approx);
      
   if (valid_provided)
      if (bestStop)
         ffNN_updated = ffNN_best;
         validCostAvg_noRegul = validCostAvg_noRegul_best;
      endif
      fprintf('      Validation: %g\n', ...
         validCostAvg_noRegul);
   endif   
   
   if (test_provided)
      testCostAvg_noRegul = ffNN_costAvg_noRegul...
      (ffNN_updated, testInput, testTargetOutput, ...
      targetOutputs_areClassIndcsColVec_ofNumClasses, ...
      testBatchDim);
      fprintf('      Test: %g\n', ...
         testCostAvg_noRegul);
   endif  

   fprintf('\n');
   
   ffNN_save(ffNN_updated, saveFileName);
   
end